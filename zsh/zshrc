source "$HOME/.zgen/zgen.zsh"

POWERLEVEL9K_DISABLE_CONFIGURATION_WIZARD=true

if ! zgen saved; then
    zgen prezto editor key-bindings 'emacs'
    zgen prezto prompt theme 'powerlevel10k'
    zgen prezto syntax-highlighting highlighters 'main' 'brackets' 'line'
    zgen prezto syntax-highlighting color 'yes'
    zgen prezto autosuggestions color 'yes'
    zgen prezto utility correct 'no'
    zgen prezto safe-ops 'no'.

    zgen prezto
    zgen prezto environment
    zgen prezto terminal
    zgen prezto editor
    zgen prezto history
    zgen prezto directory
    zgen prezto spectrum
    zgen prezto utility
    zgen prezto completion
    zgen prezto autosuggestions
    zgen prezto fasd

    zgen prezto syntax-highlighting
    zgen prezto history-substring-search
    zgen prezto prompt
fi

test -r ~/.dir_colors && eval $(dircolors ~/.dir_colors)

# Should not need to run every time, but this ensures we have completion
compinit

zmodload zsh/complist
bindkey -M menuselect '^M' .accept-line
bindkey -M menuselect '^[a' accept-search

available() {
    command -v "$1" &> /dev/null
}

autoload -Uz chpwd_recent_dirs add-zsh-hook
add-zsh-hook chpwd chpwd_recent_dirs
chpwd() {
    emulate -L zsh
    command ls -lhG --color=always --group-directories-first
}

fancy-ctrl-z () {
  if [[ $#BUFFER -eq 0 ]]; then
    BUFFER="fg"
    zle accept-line -w
  else
    zle push-input -w
    zle clear-screen -w
  fi
}
zle -N fancy-ctrl-z
bindkey '^Z' fancy-ctrl-z

bindkey '^[q' kill-buffer
bindkey '^[l' clear-screen
bindkey '^[u' undo
bindkey '^[U' redo

_accept_suggestion() {
    zle forward-char
    zle accept-line
}
zle -N _accept_suggestion
bindkey 'w' _accept_suggestion

# Shortcuts
alias z='vim ~/.zshrc'
alias todo='vim ~/.todo.txt'
alias ws='cd /workspace/'

alias rm='rm'
alias cp='cp'
alias mv='mv'
alias sc='systemctl'
alias vim='nvim'
alias mx='chmod +x'
if available bat; then alias cat='bat'; fi

alias ls='ls -h --color=auto --group-directories-first'
alias l='ls -lG'
alias ll='ls -laG'
alias lh='ls -ld .?*'
alias lr='command ls -h --color=auto -lArtG'

t()  { exa --group-directories-first -lT --color always $@ | less}
tt() { exa --group-directories-first -laT --color always $@ | less}
t2() { exa --group-directories-first -lT -L2 --color always $@ | less}

#alias tm='tmux'
alias tl='tmux ls'
alias tn='tmux new -As'
ta() { [[ -z $@ ]] && tmux attach || tmux attach -t $@ }

alias dus='du -hs * | sort -h'
alias col='column -s, -t | less -S'
alias pg='pgrep -laf'
alias pt='pstree -h'
alias pk='pkill'
alias path='echo $PATH | tr ":" "\n"'

# Docker
alias dc='docker ps'
alias dp='docker ps'
alias dca='docker ps -a'
alias dpa='docker ps -a'
alias di='docker images'
alias din='docker inspect'
alias dr='docker run'
alias ds='docker start'
alias dsp='docker stop'
alias dk='docker stop'
alias da='docker attach'
alias dl='docker logs'
alias dn='docker network'
alias drm='docker rm'
alias drmi='docker rmi'
alias dcp='docker container prune -f'

# Git
clone() {git clone $1 && cd $(basename $1 .git)}
alias g='git status -sb'
alias gg='git status'
alias ga='git add'
alias gb='git branch -avv'
alias grm='git remote -v'
alias gc='git checkout'
alias co='git checkout'
alias cm='git commit -v'
alias ca='git commit -av'
alias gd='git diff'
alias gdd='git diff --staged'
alias gds='git diff --stat'
alias gdds='git diff --staged --stat'
alias gdt='git difftool'
alias gdw='git diff --word-diff'
alias gf='git fetch'
alias gfp='git fetch --prune'
alias gfa='git fetch --all --prune'
alias gm='git merge'
alias gpl='git pull'
alias gpu='git push'
alias gsh='git show'
alias gl='git log --oneline'
alias gll='git log --oneline --all'
alias glg='git log --graph --oneline --all'
alias gls='git log --stat'
alias glp='git log -p'
alias gwh='git whatchanged -p --abbrev-commit' 
alias gsb='git show-branch'
alias sw='git switch'
alias gr='git reset'
alias grh='git reset --hard'
alias grs='git restore'
alias grb='git rebase'
# alias gg='git pull --ff-only'
alias gst='git stash'
alias gsp='git stash pop'
alias gsl='git shortlog -n --no-merges'
function gi() { curl -sLw n https://www.gitignore.io/api/$@ ;}
#todo: git extras has ignore command?
alias redit='vim $(git ls-tree --full-tree -r --name-only HEAD | fzf)'
alias gignore='vim $(git rev-parse --show-toplevel)/.gitignore'


#if [[ ! "$PATH" == */opt/fzf/bin* ]]; then
#  export PATH="${PATH:+${PATH}:}/opt/fzf/bin"
#fi
#source "/opt/fzf/shell/key-bindings.zsh"

if [[ ! "$PATH" == *$HOME/.fzf/bin* ]]; then
  export PATH="${PATH:+${PATH}:}$HOME/.fzf/bin"
fi
source "$HOME/.fzf/shell/key-bindings.zsh"

bindkey '^[r' fzf-history-widget

export FZF_DEFAULT_OPTS="
    --height=50% --reverse --inline-info
    --bind 'tab:down,btab:up,alt-q:abort,alt-n:down,alt-p:up,alt-j:down,alt-k:up,change:top'
    --color fg:-1,bg:-1,bg+:-1
    --no-hscroll
"
export FZF_ALT_C_OPTS="--prompt='./' --preview 'tree -C {} | head -200'"

v() {
    if [[ -n $@ ]]; then
        local file=$(fasd -f $@)
        [[ -n $file ]] && vim "${file}"
    else
        local file=$(fasd -ftlR | fzf --no-sort --tiebreak=index)
        [[ -n $file ]] && vim "${file}"
    fi
}
c() {
    if [[ -n $@ ]]; then
        local dir=$(fasd -d $@)
        [[ -n $dir ]] && cd "${dir}"
    else
        local dir=$(fasd -dtlR | fzf --no-sort --tiebreak=index)
        [[ -n $dir ]] && cd "${dir}"
    fi
}

siblings() {
    local target=$(command fd -d1 -td . .. --color=always | ag -v ${PWD:t} | fzf -1 -0 --ansi )
    [[ -n $target ]] && [[ -d $target ]] && cd "${target}"
}
alias s='siblings'

_local_files() {
    zle kill-buffer
    # local file=$(find -type f | fzf --prompt='./' --ansi --preview 'bat --color=always --style=header,grid --line-range :300 {}')
    local file=$(find -L -type f | fzf --prompt='./' --ansi --preview 'bat --color=always --style=header,grid --line-range :300 {}')
    if [[ -n $file ]]; then
        file=$(realpath $file)
        zle redisplay
        if [[ ! $(file --mime $file) =~ 'binary' ]]; then
            BUFFER="vim \"${file}\""
            zle accept-line
        fi
    else
        zle reset-prompt
    fi
}
zle -N _local_files
bindkey '^[e' _local_files

_kill_process() {
    zle kill-buffer
    local process=$(ps -N --ppid 2 -p 2 -o s,user,pid,pcpu,pmem,comm --sort -pcpu,-pmem | fzf --header-lines=1 | awk '{print $3}')
    if [[ -n $process ]]; then
        echo $process
        zle redisplay
        kill $process 2> /dev/null || sudo kill $process
        zle accept-line
    else
        zle reset-prompt
    fi
}
zle -N _kill_process
bindkey '^[k' _kill_process

_parent_dir() {
    cd ..
    zle kill-buffer
    zle accept-line
}
zle -N _parent_dir
bindkey '^[[1;3A' _parent_dir

# fs() {
#     local -r fmt='#{session_id}:|#S|(#{session_attached} attached)'
#     { tmux display-message -p -F "$fmt" && tmux list-sessions -F "$fmt"; } \
#         | awk '!seen[$1]++' \
#         | column -t -s'|' \
#         | fzf -q '$' --reverse --prompt 'switch session: ' -1 -0 \
#         | cut -d':' -f1 \
#         | xargs tmux switch-client -t
# }

#fs() {
#  local session
#  session=$(tmux list-sessions -F "#{session_name}" | \
#    fzf --query="$1" --select-1 --exit-0) &&
#  tmux switch-client -t "$session"
#}



# tm() {
#   [[ -n "$TMUX" ]] && change="switch-client" || change="attach-session"
#   if [ $1 ]; then
#     tmux $change -t "$1" 2>/dev/null || (tmux new-session -d -s $1 && tmux $change -t "$1"); return
#   fi
#   session=$(tmux list-sessions -F "#{session_name}" 2>/dev/null | fzf --exit-0) &&  tmux $change -t "$session" || echo "No sessions found."
# }

#compdef c=fasd_cd

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

